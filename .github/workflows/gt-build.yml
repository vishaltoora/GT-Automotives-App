name: GT-Automotive-Build
on:
  push:
    branches:
      - 'main'
      - 'release/*'
      - 'buildtest/*'
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/gt-backend
  RESOURCE_GROUP: gt-automotives-prod
  DISABLE_ERD: true
  PUPPETEER_SKIP_CHROMIUM_DOWNLOAD: true

permissions:
  contents: read
  packages: write

jobs:
  Build:
    runs-on: ubuntu-latest
    outputs:
      build-number: ${{ steps.build-info.outputs.build-number }}
      frontend-artifact: ${{ steps.build-info.outputs.frontend-artifact }}
      backend-artifact: ${{ steps.build-info.outputs.backend-artifact }}
      docker-image: ${{ steps.build-info.outputs.docker-image }}

    steps:
      # Temporarily removed AutoModality/action-clean@v1 due to Docker Hub 401 errors

      - uses: actions/checkout@v4

      - name: Generate build info
        id: build-info
        run: |
          BUILD_NUMBER="build-$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA:0:7}"
          echo "build-number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "frontend-artifact=frontend-$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "backend-artifact=backend-$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "docker-image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "ğŸ—ï¸ Build Number: $BUILD_NUMBER"

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'

      # Advanced caching strategy (MyPersn pattern)
      - name: Cache dependencies and build outputs
        uses: actions/cache@v3
        with:
          path: |
            ~/.yarn/cache
            node_modules
            .nx/cache
            apps/webApp/dist
            dist/libs/data
          key: ${{ runner.os }}-gt-deps-${{ hashFiles('yarn.lock', 'package.json') }}
          restore-keys: |
            ${{ runner.os }}-gt-deps-
            ${{ runner.os }}-gt-

      - name: Install dependencies
        run: |
          echo "ğŸ“¦ Installing dependencies with caching..."
          yarn install --frozen-lockfile --ignore-engines --network-timeout 100000

      - name: Generate Prisma Client
        run: |
          echo "ğŸ”§ Generating Prisma client..."
          yarn prisma generate --schema=libs/database/src/lib/prisma/schema.prisma

      # Parallel linting and type checking
      - name: Code Quality Checks
        run: |
          echo "ğŸ” Running parallel code quality checks..."
          yarn lint &
          LINT_PID=$!
          yarn typecheck &
          TYPE_PID=$!

          # Wait for both processes
          wait $LINT_PID
          LINT_EXIT=$?
          wait $TYPE_PID
          TYPE_EXIT=$?

          if [ $LINT_EXIT -ne 0 ] || [ $TYPE_EXIT -ne 0 ]; then
            echo "âŒ Code quality checks failed"
            exit 1
          fi
          echo "âœ… Code quality checks passed"

      # Tests (commented out but ready to enable)
      # - name: Run Tests
      #   run: |
      #     echo "ğŸ§ª Running tests..."
      #     yarn test

      # Fetch VITE environment variables from Azure Web App
      - name: Fetch VITE Environment Variables from Azure
        run: |
          echo "ğŸ” Fetching VITE environment variables from Azure Web App..."

          # Fetch settings from Azure Web App
          VITE_SETTINGS=$(az webapp config appsettings list \
            --name gt-automotives-frontend \
            --resource-group gt-automotives-prod \
            --query "[?starts_with(name, 'VITE_')].{name:name, value:value}" \
            -o json)

          # Extract individual values
          export VITE_API_URL=$(echo "$VITE_SETTINGS" | jq -r '.[] | select(.name=="VITE_API_URL") | .value')
          export VITE_CLERK_PUBLISHABLE_KEY=$(echo "$VITE_SETTINGS" | jq -r '.[] | select(.name=="VITE_CLERK_PUBLISHABLE_KEY") | .value')
          export VITE_GOOGLE_MAPS_API_KEY=$(echo "$VITE_SETTINGS" | jq -r '.[] | select(.name=="VITE_GOOGLE_MAPS_API_KEY") | .value')

          # Save to GITHUB_ENV for subsequent steps
          echo "VITE_API_URL=$VITE_API_URL" >> $GITHUB_ENV
          echo "VITE_CLERK_PUBLISHABLE_KEY=$VITE_CLERK_PUBLISHABLE_KEY" >> $GITHUB_ENV
          echo "VITE_GOOGLE_MAPS_API_KEY=$VITE_GOOGLE_MAPS_API_KEY" >> $GITHUB_ENV

          echo "âœ… VITE environment variables loaded from Azure"
          echo "   VITE_API_URL: $VITE_API_URL"

      # Parallel frontend and shared library builds
      - name: Build Frontend and Shared Libraries
        env:
          NODE_ENV: production
        run: |
          echo "ğŸŒ Building frontend and shared libraries in parallel..."
          echo "   Using VITE_API_URL: $VITE_API_URL"

          yarn build:web &
          FRONTEND_PID=$!
          yarn nx build data &
          SHARED_PID=$!

          # Wait for both builds
          wait $FRONTEND_PID
          FRONTEND_EXIT=$?
          wait $SHARED_PID
          SHARED_EXIT=$?

          if [ $FRONTEND_EXIT -ne 0 ] || [ $SHARED_EXIT -ne 0 ]; then
            echo "âŒ Build failed"
            exit 1
          fi
          echo "âœ… Frontend and shared libraries built successfully"

      - name: Prepare Frontend Artifact
        run: |
          echo "ğŸ“¦ Creating frontend deployment package..."
          cd apps/webApp/dist

          # Create Node.js server with API proxy (optimized)
          cat > server.js << 'EOF'
          const express = require('express');
          const { createProxyMiddleware } = require('http-proxy-middleware');
          const path = require('path');
          const app = express();
          const PORT = process.env.PORT || 8080;

          // Backend configuration - Using Azure Web App deployment
          const BACKEND_URL = 'https://gt-automotives-backend-api.azurewebsites.net';

          // Secure CORS configuration for proxy
          const allowedOrigins = [
            'https://gt-automotives.com',
            'https://www.gt-automotives.com',
            'http://localhost:4200',
            'http://localhost:3000'
          ];

          app.use('/api', (req, res, next) => {
            const origin = req.headers.origin;

            // Allow requests with no origin (server-to-server, mobile apps)
            if (!origin) {
              res.header('Access-Control-Allow-Origin', '*');
            }
            // Check if origin is allowed
            else if (allowedOrigins.includes(origin)) {
              res.header('Access-Control-Allow-Origin', origin);
              res.header('Access-Control-Allow-Credentials', 'true');
            }
            // Block unauthorized origins - DO NOT set any CORS headers
            else {
              console.error(`ğŸš« CORS Security: Blocked unauthorized origin: ${origin}`);
              // IMPORTANT: Do not set any CORS headers for blocked origins
              // This ensures the browser will block the request
              // For preflight OPTIONS, return 403 Forbidden
              if (req.method === 'OPTIONS') {
                return res.status(403).json({
                  error: 'CORS policy violation',
                  message: `Origin ${origin} is not allowed`
                });
              }
              // For other requests, continue but browser will block due to missing headers
            }

            res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,PATCH,DELETE,OPTIONS');
            res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');

            if (req.method === 'OPTIONS') {
              res.sendStatus(200);
            } else {
              next();
            }
          });

          app.use('/api', createProxyMiddleware({
            target: BACKEND_URL,
            changeOrigin: true,
            timeout: 30000,
            onProxyReq: (proxyReq, req, res) => {
              // SECURITY: Add internal API key for backend authentication
              // This key is fetched from Azure App Settings at runtime
              const internalApiKey = process.env.INTERNAL_API_KEY;

              if (!internalApiKey) {
                console.error('ğŸš¨ CRITICAL: INTERNAL_API_KEY not set in environment!');
              } else {
                proxyReq.setHeader('X-Internal-API-Key', internalApiKey);
              }

              // Add proxy headers for request tracking
              proxyReq.setHeader('X-Forwarded-For', req.ip || req.connection.remoteAddress);
              proxyReq.setHeader('X-Real-IP', req.ip || req.connection.remoteAddress);
              proxyReq.setHeader('X-Original-Host', req.headers.host);
              proxyReq.setHeader('X-Forwarded-Proto', 'https');

              // Log proxied requests for monitoring
              console.log(`[PROXY] ${req.method} ${req.path} from ${req.ip} [Key: ${internalApiKey ? 'SET' : 'MISSING'}]`);
            },
            onError: (err, req, res) => {
              console.error('Proxy error:', err.message);
              res.status(500).json({ error: 'Backend service unavailable', message: err.message });
            }
          }));

          // Health check
          app.get('/health', (req, res) => {
            res.json({
              status: 'healthy',
              service: 'gt-automotive-web-app',
              backend: BACKEND_URL,
              build: '${{ steps.build-info.outputs.build-number }}',
              timestamp: new Date().toISOString()
            });
          });

          app.use(express.static(__dirname));
          app.get('*', (req, res) => {
            res.sendFile(path.join(__dirname, 'index.html'));
          });

          app.listen(PORT, () => {
            console.log(`ğŸš€ GT Automotive Web App running on port ${PORT}`);
            console.log(`ğŸ“¡ Proxying API requests to: ${BACKEND_URL}`);
            console.log(`ğŸ—ï¸ Build: ${{ steps.build-info.outputs.build-number }}`);
          });
          EOF

          # Create optimized package.json
          cat > package.json << 'EOF'
          {
            "name": "gt-automotives-frontend",
            "version": "${{ steps.build-info.outputs.build-number }}",
            "description": "GT Automotive Web App with API Proxy",
            "scripts": {
              "start": "node server.js"
            },
            "dependencies": {
              "express": "^4.18.2",
              "http-proxy-middleware": "^2.0.6"
            },
            "engines": {
              "node": ">=20"
            }
          }
          EOF

          # Create deployment zip
          zip -r ../../../${{ steps.build-info.outputs.frontend-artifact }}.zip .
          cd ../../..

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get branch name
        id: branch-name
        uses: tj-actions/branch-names@v6

      # Optimized Docker build with caching
      - name: Build, Tag & Push Docker image to GitHub Container Registry
        env:
          DOCKER_IMAGE: ${{ steps.build-info.outputs.docker-image }}
          BUILD_TAG: ${{ steps.branch-name.outputs.current_branch }}-${{ github.run_number }}
        run: |
          echo "ğŸ³ Building optimized Docker image with caching..."

          # Enable BuildKit for better performance
          export DOCKER_BUILDKIT=1

          # Convert image name to lowercase (GHCR requirement)
          IMAGE_LOWER=$(echo "${{ env.DOCKER_IMAGE }}" | tr '[:upper:]' '[:lower:]')
          CACHE_IMAGE=$(echo "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache" | tr '[:upper:]' '[:lower:]')

          # Try to pull cache image (ignore error if it doesn't exist yet)
          echo "ğŸ” Attempting to pull cache image..."
          docker pull $CACHE_IMAGE || echo "âš ï¸ No cache image found, building from scratch..."

          # Build with simple Dockerfile (single-stage, more reliable)
          docker build \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            --progress=plain \
            -f Dockerfile \
            -t $IMAGE_LOWER \
            -t $CACHE_IMAGE \
            .

          echo "ğŸ“¤ Pushing images to GitHub Container Registry (FREE)..."
          docker push $IMAGE_LOWER
          docker push $CACHE_IMAGE

          echo "IMAGE_TAG=$IMAGE_LOWER" >> build-info.txt
          echo "BUILD_TAG=$BUILD_TAG" >> build-info.txt
          echo "BUILD_NUMBER=${{ steps.build-info.outputs.build-number }}" >> build-info.txt

      - name: Upload Frontend Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.build-info.outputs.frontend-artifact }}
          path: ${{ steps.build-info.outputs.frontend-artifact }}.zip
          retention-days: 30

      - name: Upload Build Information
        uses: actions/upload-artifact@v4
        with:
          name: build-info-${{ steps.build-info.outputs.build-number }}
          path: build-info.txt
          if-no-files-found: error

      - name: Upload Repository Artifact (for deployment)
        uses: actions/upload-artifact@v4
        with:
          name: repo-${{ steps.build-info.outputs.build-number }}
          path: |
            ./
            !node_modules
            !apps/webApp/dist
            !.nx/cache
          if-no-files-found: error
          include-hidden-files: true

      - name: Create Build Summary
        run: |
          echo "## ğŸš€ Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Build Number:** \`${{ steps.build-info.outputs.build-number }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Docker Image:** \`${{ steps.build-info.outputs.docker-image }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“¦ Artifacts Created" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend:** \`${{ steps.build-info.outputs.frontend-artifact }}.zip\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend:** Docker image pushed to GitHub Container Registry (FREE)" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository:** Source code for migrations" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ¯ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "To deploy this build, go to **Actions** â†’ **GT-Automotive-Deploy** and enter:" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Number:** \`${{ steps.build-info.outputs.build-number }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âš¡ Performance Optimizations Applied" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Advanced dependency caching" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Parallel builds (frontend + shared libraries)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Parallel code quality checks" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Docker BuildKit with layer caching" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Optimized artifact packaging" >> $GITHUB_STEP_SUMMARY

      - name: Build Completed
        run: |
          echo "âœ… Optimized build completed successfully!"
          echo "ğŸ—ï¸ Build Number: ${{ steps.build-info.outputs.build-number }}"
          echo "ğŸ³ Docker Image: ${{ steps.build-info.outputs.docker-image }}"
          echo "ğŸ“¦ Frontend Artifact: ${{ steps.build-info.outputs.frontend-artifact }}.zip"
          echo "âš¡ MyPersn optimization patterns applied"
