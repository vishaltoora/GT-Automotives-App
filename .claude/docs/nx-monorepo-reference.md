# Nx Monorepo Reference Guide

## Overview

Nx is a powerful monorepo framework that enables efficient development, building, and deployment of multiple interconnected applications and libraries. This guide covers GT Automotive's specific Nx configuration and best practices.

## Project Structure

```
gt-automotives-app/
├── apps/
│   └── webApp/                 # React frontend application
├── server/                     # NestJS backend application
├── libs/
│   ├── database/              # Prisma database library
│   └── shared-dto/            # Shared data transfer objects
├── dist/                      # Build output directory
│   ├── apps/webApp/          # Frontend build output
│   ├── server/               # Backend webpack build output
│   └── libs/                 # Library build outputs
├── node_modules/
├── package.json              # Root package.json with workspace scripts
├── nx.json                   # Nx workspace configuration
└── tsconfig.base.json        # Shared TypeScript configuration
```

## Key Concepts

### 1. Build Outputs and Paths

**Frontend (React/Vite)**
- **Source**: `apps/webApp/`
- **Build Command**: `yarn build:web` or `nx build webApp`
- **Output**: `apps/webApp/dist/` (Vite default) → copied to `dist/apps/webApp/`
- **Entry Point**: `apps/webApp/dist/index.html`

**Backend (NestJS/Webpack)**
- **Source**: `server/src/main.ts`
- **Build Command**: `yarn build:server` or `nx build server`
- **Webpack Config**: `server/webpack.config.js`
- **Output Path**: `dist/server/` (configured in webpack.config.js)
- **Main File**: `dist/server/main.js`
- **Package.json**: `dist/server/package.json` (auto-generated by Nx)

**Libraries**
- **Database**: `libs/database/` → `dist/libs/database/`
- **Shared DTO**: `libs/shared-dto/` → `dist/libs/shared-dto/`

### 2. Build Targets and Commands

```bash
# Individual project builds
yarn build:web          # Frontend only (nx build webApp)
yarn build:server       # Backend only (nx build server)

# Library builds
yarn nx build database      # Build database library
yarn nx build shared-dto    # Build shared DTO library

# Complete builds
yarn build              # All projects (nx run-many --target=build --all)
yarn typecheck          # All projects type checking
yarn lint              # All projects linting
```

### 3. Webpack Configuration (Backend)

```javascript
// server/webpack.config.js
const { NxAppWebpackPlugin } = require('@nx/webpack/app-plugin');
const { join } = require('path');

module.exports = {
  output: {
    path: join(__dirname, '../dist/server'), // Output to project root dist/server/
  },
  plugins: [
    new NxAppWebpackPlugin({
      target: 'node',           // Node.js backend
      compiler: 'tsc',          # TypeScript compilation
      main: './src/main.ts',    # Entry point
      outputHashing: 'none',    # No hash in filenames
      generatePackageJson: true, # Auto-generate package.json
    }),
  ],
};
```

### 4. External Dependencies (Critical for Containers)

Webpack externalizes certain dependencies to avoid bundling issues:

```javascript
// Externalized dependencies (not bundled):
- @prisma/client          # Prisma requires native binaries
- .prisma/client          # Generated Prisma client
- @gt-automotive/shared-dto  # Shared library (resolved via node_modules)
```

## Common Build Issues and Solutions

### Issue 1: "Cannot find module @gt-automotive/shared-dto"

**Cause**: Shared library not built or not properly linked in node_modules

**Solution**:
```bash
# Always build shared libraries first
yarn nx build shared-dto
yarn build:server
```

### Issue 2: "main.js not found" in deployment

**Paths to Check**:
- ✅ **Correct**: `dist/server/main.js` (webpack output)
- ❌ **Wrong**: `server/dist/main.js` (this contains only .d.ts files)

**Verification**:
```bash
# Check actual webpack output
ls -la dist/server/main.js

# TypeScript definitions are separate
ls -la server/dist/main.d.ts
```

### Issue 3: Prisma Client Issues in Containers

**Problem**: Prisma client needs proper binary compilation for container environment

**Solution**:
```dockerfile
# Install Prisma CLI and generate client in container
RUN npm install prisma@latest && \
    npx prisma generate --schema=./prisma/schema.prisma
```

### Issue 4: Shared Library Resolution in Containers

**Problem**: Webpack externalizes shared libraries but they're not available in container

**Solution**: Manual node_modules structure creation:
```bash
# Create proper node_modules structure
mkdir -p ./node_modules/@gt-automotive/shared-dto/dist/
cp -r ./shared-dto-temp/* ./node_modules/@gt-automotive/shared-dto/dist/
cp ./shared-dto-package.json ./node_modules/@gt-automotive/shared-dto/package.json
```

## Development Workflow

### 1. Starting Development

```bash
# Install dependencies
yarn install --frozen-lockfile --ignore-engines

# Generate Prisma client
yarn prisma generate --schema=libs/database/src/lib/prisma/schema.prisma

# Start development servers
yarn dev                    # Both frontend and backend
# OR separately:
yarn dev:web               # Frontend only (port 4200)
yarn dev:server            # Backend only (port 3000)
```

### 2. Making Changes

**Frontend Changes**:
- Edit files in `apps/webApp/src/`
- Hot reload available in development
- Build with `yarn build:web`

**Backend Changes**:
- Edit files in `server/src/`
- Restart required in development
- Build with `yarn build:server`

**Shared Library Changes**:
- Edit files in `libs/shared-dto/src/`
- Must rebuild library: `yarn nx build shared-dto`
- Then rebuild consuming projects

### 3. Building for Production

```bash
# Clean build
yarn nx reset               # Clear Nx cache
yarn build                 # Build all projects
```

## Container Deployment Patterns

### 1. Multi-Stage Dockerfile (Not Recommended for GT Automotive)

Issues with shared libraries and Prisma client generation.

### 2. Single-Stage with Pre-Built Artifacts (Recommended)

```dockerfile
FROM node:20-slim
WORKDIR /app

# Copy deployment package (already built externally)
COPY . ./

# Install runtime dependencies and generate Prisma client
RUN npm install --production && \
    npx prisma generate --schema=./prisma/schema.prisma

# Create proper node_modules structure for externalized dependencies
RUN mkdir -p ./node_modules/@gt-automotive/shared-dto/dist/ && \
    cp -r ./shared-dto-temp/* ./node_modules/@gt-automotive/shared-dto/dist/

CMD ["node", "server/main.js"]
```

### 3. Deployment Package Structure

```
backend-deploy/
├── server/                 # Webpack build output
│   ├── main.js            # Main application file
│   ├── package.json       # Auto-generated dependencies
│   └── ...                # Other webpack outputs
├── prisma/                # Database schema and migrations
│   ├── schema.prisma
│   └── migrations/
├── shared-dto-temp/       # Temporary shared library files
├── package.json           # Production dependencies
└── Dockerfile             # Container definition
```

## Nx Commands Reference

### Project Management
```bash
# List all projects
nx show projects

# Show project details
nx show project server
nx show project webApp

# Project dependencies
nx graph                   # Visual dependency graph
```

### Building and Testing
```bash
# Build specific project
nx build server
nx build webApp
nx build shared-dto

# Build with specific configuration
nx build server --configuration=production

# Run tests
nx test server
nx test webApp

# Lint projects
nx lint server
nx lint webApp
```

### Cache Management
```bash
# Clear all caches
nx reset

# Show cache status
nx show cache
```

### Advanced Commands
```bash
# Build all affected projects (based on git changes)
nx affected:build

# Run multiple targets
nx run-many --target=build --projects=server,webApp

# Run all builds in parallel
nx run-many --target=build --all --parallel
```

## Troubleshooting

### Build Cache Issues

**Symptoms**: Builds using outdated files, changes not reflected

**Root Causes**:
- Stale computation cache
- Incorrect cache inputs configuration
- Changes to external dependencies not detected

**Solutions**:
```bash
nx reset                   # Clear Nx cache
rm -rf dist/              # Clear build outputs
yarn build                # Clean rebuild

# Debug cache issues
nx build server --verbose  # Show detailed cache information
nx show cache             # Display cache status

# Temporarily bypass cache
nx build server --skip-nx-cache
```

**Cache Debugging Tips**:
- Check if inputs are properly configured in `nx.json`
- Verify that side effects are properly handled
- Use `--verbose` flag to understand cache behavior
- Review cache location with `nx show cache`

### TypeScript Path Mapping Issues

**Problem**: Import paths not resolving correctly

**Check**: `tsconfig.base.json` paths configuration:
```json
{
  "compilerOptions": {
    "paths": {
      "@gt-automotive/shared-dto": ["libs/shared-dto/src/index.ts"],
      "@gt-automotive/database": ["libs/database/src/index.ts"]
    }
  }
}
```

### Webpack and Build Issues

**Webpack Externals Not Working**

*Symptoms*: Large bundle sizes, Prisma/shared-dto bundled incorrectly

*Solutions*:
- Check webpack.config.js externals configuration
- Verify dependencies are properly externalized
- Use Nx webpack plugin generators to reconfigure: `nx g @nx/webpack:configuration`

**Webpack Plugin Migration Issues**

*Symptoms*: Build failures after Nx updates

*Solutions*:
```bash
# Convert to latest Nx webpack plugin format
nx g @nx/webpack:convert-to-inferred --project=server

# Update webpack plugin configuration
nx g @nx/webpack:convert-config-to-webpack-plugin --project=server
```

**Development Server Issues**

*Symptoms*: Hot reload not working, server not starting

*Solutions*:
```bash
# Use proper dev-server executor
nx serve server --executor=@nx/webpack:dev-server

# Check project.json for proper dev-server configuration
nx show project server

# Reset and restart development server
nx reset && nx serve server
```

## Nx Core Concepts and Best Practices

### 1. Task Caching and Performance

**Computation Caching**
- Nx provides a "sophisticated and battle-tested computation caching system that ensures code is never rebuilt twice"
- Caching "drastically speeds up your task execution times" and "saves you money on CI/CD costs"
- Cacheable operations must be "side effect free" - identical inputs always produce identical outputs

**Cache Configuration**:
```json
// nx.json
{
  "targetDefaults": {
    "build": { "cache": true },
    "test": { "cache": true },
    "lint": { "cache": true }
  }
}
```

**Cache Management**:
```bash
# Clear all caches
nx reset

# Show cache status
nx show cache

# Skip cache for specific command
nx build server --skip-nx-cache
```

### 2. Affected Commands for CI/CD Optimization

**Core Concept**: Run tasks only on projects impacted by code changes

```bash
# Build only affected projects
nx affected -t build

# Test only affected projects
nx affected -t test

# Lint only affected projects
nx affected -t lint

# Visualize affected projects
nx graph --affected
```

**Best Practices**:
- Set base SHA to the "latest successful commit" on the main branch
- Configure CI to use appropriate base and head commit references
- Pair affected commands with remote caching for maximum efficiency

### 3. Project Organization Patterns

**Library Types** (Recommended by Nx):
- **Feature libraries**: Business logic and features
- **UI libraries**: Reusable components
- **Data-access libraries**: API calls and state management
- **Utility libraries**: Pure functions and helpers

**Code Ownership**:
- Use CODEOWNERS files for shared code
- Implement module boundary rules
- Clear project boundaries for better maintainability

### 4. Build Order Dependencies
Always build in dependency order:
1. `shared-dto` (no dependencies)
2. `database` (may depend on shared-dto)
3. `server` (depends on both)
4. `webApp` (depends on shared-dto)

### 5. Dependency Graph and Project Management

**Dependency Visualization**:
```bash
# Visual dependency graph
nx graph

# Show specific project dependencies
nx show project server

# List all projects
nx show projects
```

**Project Structure Considerations**:
- Project granularity impacts build speed, code boundaries, and developer experience
- Enable seamless code sharing and atomic changes
- Maintain consistent development practices across projects

### 6. Container Deployment
- Use single-stage Dockerfile with pre-built artifacts
- Generate Prisma client in container environment
- Manually create node_modules structure for externalized dependencies

### 7. Development Efficiency

**Performance Optimization**:
- Use `nx affected` commands when working on large changes
- Keep Nx cache enabled for faster builds
- Use `--skip-nx-cache` flag when troubleshooting cache issues
- Configure remote caching with `npx nx@latest connect` for team cache sharing

**Task Execution Patterns**:
```bash
# Parallel execution for maximum speed
nx run-many --target=build --all --parallel

# Run specific targets in sequence
nx run-many --target=build --projects=shared-dto,server

# Use affected for incremental changes
nx affected:build --base=main
```

### 8. Shared Libraries and Code Organization

**Shared Library Best Practices**:
- Always version shared libraries properly
- Build shared libraries before dependent projects
- Test shared library changes across all consuming projects
- Follow Nx library categorization (feature, ui, data-access, utility)

**Code Sharing Patterns**:
- Enable atomic changes across multiple projects
- Use TypeScript path mapping for clean imports
- Maintain clear module boundaries
- Implement proper dependency injection patterns

## Advanced Nx Features

### 1. Cache Optimization

**Input Configuration**:
- Configure what's included in cache hash (files, environment variables)
- Specify output folders where task-generated files are stored
- Can be configured globally in `nx.json` or per-project

**Remote Caching Benefits**:
- Share cache between different CI runs
- Reduce computational overhead across team
- Minimize unnecessary task executions in distributed environments

### 2. Plugin System

**Automatic Configuration**:
- Nx plugins automatically infer tasks and configure caching based on configuration files
- Example: Adding `@nx/vite` automatically detects and configures Vite task caching
- Plugins provide opinionated defaults while allowing customization

### 3. CI/CD Integration

**GitHub Actions Optimization**:
```yaml
# Optimized CI workflow using affected commands
- name: Build affected projects
  run: nx affected -t build --base=${{ github.event.before }}

- name: Test affected projects
  run: nx affected -t test --base=${{ github.event.before }}
```

**Webpack-Specific CI/CD Patterns**:
```bash
# Build specific projects with webpack
nx build server --configuration=production

# Use affected commands with webpack builds
nx affected -t build --configuration=production

# Webpack-specific development server
nx serve server  # Uses dev-server executor

# SSR development server
nx serve server --executor=@nx/webpack:ssr-dev-server
```

**Webpack Configuration Management**:
```bash
# Add webpack configuration to existing project
nx g @nx/webpack:configuration --project=server

# Convert existing webpack project to Nx plugin
nx g @nx/webpack:convert-config-to-webpack-plugin --project=server

# Migrate to inferred configuration
nx g @nx/webpack:convert-to-inferred --project=server
```

**Configuration for Dependency Updates**:
```json
{
  "pluginsConfig": {
    "@nx/js": {
      "projectsAffectedByDependencyUpdates": "auto"
    }
  }
}
```

## Production Checklist

### Build Verification
- [ ] All projects build successfully (`yarn build`)
- [ ] Type checking passes (`yarn typecheck`)
- [ ] Linting passes (`yarn lint`)
- [ ] Tests pass (`yarn test`)
- [ ] Affected commands work correctly (`nx affected:build`)

### Cache and Performance
- [ ] Cache configuration verified in `nx.json`
- [ ] Remote caching connected if using Nx Cloud
- [ ] Dependency graph validated (`nx graph`)
- [ ] Build outputs verified at expected paths

### Deployment
- [ ] Prisma client generated (`yarn prisma generate`)
- [ ] Container deployment tested locally
- [ ] Environment variables configured
- [ ] Database migrations applied
- [ ] CI/CD pipeline uses affected commands for optimization

## Advanced Troubleshooting

### Affected Commands Not Working

**Symptoms**: Affected commands building/testing too many or too few projects

**Solutions**:
```bash
# Check affected graph
nx graph --affected

# Verify base/head configuration
nx affected:build --base=origin/main --head=HEAD

# Check .nxignore for excluded files
cat .nxignore
```

### Dependency Graph Issues

**Symptoms**: Circular dependencies, incorrect build order

**Solutions**:
```bash
# Visualize dependency graph
nx graph

# Check specific project dependencies
nx show project server --with-deps

# Identify circular dependencies
nx graph --focus=server
```

### Performance Optimization

**Slow Builds**:
- Enable remote caching: `npx nx@latest connect`
- Use affected commands: `nx affected:build`
- Optimize webpack externals configuration
- Check for unnecessary file inclusions in cache inputs

**Memory Issues**:
```bash
# Increase Node.js memory limit
NODE_OPTIONS="--max-old-space-size=4096" nx build server

# Use parallel execution carefully
nx run-many --target=build --all --parallel=2
```

### Plugin and Configuration Issues

**Plugin Compatibility**:
- Check Nx version compatibility with webpack plugin version
- Use `nx migrate` for updating plugins consistently
- Verify plugin configuration in `nx.json`

**Configuration Conflicts**:
- Check for conflicting executors in `project.json`
- Verify path mappings in `tsconfig.base.json`
- Ensure webpack externals align with package.json dependencies

---

**Last Updated**: September 24, 2025
**Status**: Comprehensive Nx documentation based on official docs
**Coverage**: Core concepts, webpack integration, caching, affected commands, troubleshooting
**Source**: Official Nx documentation (nx.dev) + GT Automotive specific patterns

This reference guide should be updated as the Nx configuration evolves and new patterns emerge during development and deployment.